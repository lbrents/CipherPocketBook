package com.example.cipherpocketbook.ciphers

import com.example.cipherpocketbook.Alphabet
import com.example.cipherpocketbook.gcd
import operations.determinant
import operations.inverse
import real.ColumnVector
import real.Matrix
import kotlin.math.ceil
import kotlin.math.floor
import kotlin.math.sqrt
import kotlin.text.uppercase

private fun String.toMatrix(alphabet: String): Matrix {

    // Check arguments for validity
    if (alphabet.isEmpty()) return Matrix(2, 1)

    // Cleaned arguments
    val clnAlphabet = alphabet
        .uppercase()
    val clnKey = this
        .uppercase()
        .filter { it in clnAlphabet }

    // Error check if the cleaned key is not empty or 1 char long
    if (clnKey.isEmpty() || clnKey.length == 1) return Matrix(2, 1)

    // Error check if the sqrt of the key's length is not a whole number
    val size = sqrt(clnKey.length.toDouble())
    if (floor(size) != ceil(size)) return Matrix(2, 1)

    // Return a matrix with each index mapped to a character from the key
    return Matrix(size.toInt(), size.toInt()) { row, col ->
        clnAlphabet.indexOf( clnKey[ (row * size.toInt()) + col ] )
    }.also { println(it) }

}

private fun encrypt(
    msg: String,
    key: Matrix,
    alphabet: String,
    padChar: Char?
): String {

    // Check arguments for validity
    if (msg.isEmpty()) return ""
    if (key.rows != key.cols) return "Matrix (or string length) must be square"
    if (alphabet.isEmpty()) return ""

    // Cleaned arguments
    val clnAlphabet = alphabet
        .uppercase()

    val size = key.rows
    var text = ""
    /**
     * 1. Transform message to uppercase
     * 2. Filter out all characters not in given alphabet
     * 3. Split text into n sized chunks and make sure to pad every chunk to maximum size
     * 4. For each chunk, turn it into a vector and then multiply that by the key matrix
     * 5. Add the characters generated by the multiplication to a single string
     */
    msg
        .uppercase()
        .filter { it in clnAlphabet }
        .chunked(size) { it.padEnd(size, padChar ?: clnAlphabet.random()) }
        .map { block ->
            val col = ColumnVector(size) { index -> clnAlphabet.indexOf(block[index]) }
            (key * col).map { text += clnAlphabet[it.toInt() % clnAlphabet.length]; it }
        }

    return text

}

private fun decrypt(
    msg: String,
    key: Matrix,
    alphabet: String
): String {

    // Check arguments for validity
    if (msg.isEmpty()) return ""
    if (key.rows != key.cols) return "Matrix (or string length) must be square"
    if (alphabet.isEmpty()) return ""

    // Cleaned arguments
    val clnAlphabet = alphabet
        .uppercase()

    // Math
    val size = key.rows
    val keyInv = key.inverse().map { Math.floorMod(it.toInt(), alphabet.length) }
    val keyDet = keyInv.determinant() % alphabet.length
    val coprime = keyDet.toInt() gcd alphabet.length

    // Error check if determinant is not coprimes with the alphabet length
    if (coprime != 1) return "Inverse key matrix's determinant and alphabet length are not coprimes"

    var text = ""
    /**
     * 1. Transform message to uppercase
     * 2. Filter out all characters not in given alphabet
     * 3. Split the message into n sized chunks
     * 4. Multiply each chunk's vector by the calculated inverse matrix to get the original message
     */
    msg
        .uppercase()
        .filter { it in clnAlphabet }
        .chunked(size)
        .map { block ->
            val col = ColumnVector(size) { index -> clnAlphabet.indexOf(block[index]) }
            (keyInv * col).map { text += alphabet[it.toInt() % alphabet.length]; it }
        }

    return text

}

fun String.hill(
    key: Matrix,
    alphabet: String = Alphabet.uppercase(),
    padChar: Char? = null,
    decrypt: Boolean = false
) = when (decrypt) {

    true  -> decrypt(this, key, alphabet)
    false -> encrypt(this, key, alphabet, padChar)

}

fun String.hill(
    key: String,
    alphabet: String = Alphabet.uppercase(),
    padChar: Char? = null,
    decrypt: Boolean = false
): String {
    val keyMatrix = key.toMatrix(alphabet)
    return this.hill(keyMatrix, alphabet, padChar, decrypt)
}